% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_stan_outputs.R
\name{generate_sample}
\alias{generate_sample}
\alias{get_transformed_data}
\alias{get_parameters}
\alias{get_mle}
\alias{gen_sample}
\title{Generate samples from a fitted ensemble model.}
\usage{
generate_sample(fit, num_samples = 1)

get_transformed_data(fit)

get_parameters(ex.fit, x = 1)

get_mle(x = 1, ex.fit, transformed_data, time)

gen_sample(x = 1, ex.fit, transformed_data, time)
}
\arguments{
\item{fit}{An \code{EnsembleFit} object.}

\item{num_samples}{The number of samples generated if the \code{EnsembleFit} object is not a full sampling of the posterior of the ensemble model. The default is 1. If the \code{EnsembleFit} object is a full sampling of the posterior, then the number of samples will be the same as the number of samples in the ensemble MCMC. (I don't understand this James)}

\item{ex.fit}{The extracted samples / point estimate from the \code{EnsembleFit} object. For samples, this should be the output of \code{rstan::extract()} on the \code{stanfit} object and for point estimate outputs this should be the \code{par} slot.}

\item{x}{The sample of parameters from the ensemble model to use (if the \code{EnsembleFit} object is a full sampling, otherwise uses the MLE). The default is 1.}

\item{transformed_data}{James?}

\item{time}{A non-negative integer specifying the time for which the ensemble model was run. (I don't understand)}
}
\value{
\code{generate_sample} gives a \code{list} of length 2, with the first element being the MLE of latent variables and the second element being samples of the latent variables.
\itemize{
\item If \code{fit} is a full MCMC sampling of the ensemble model, then:
\itemize{
\item \code{mle} is a \code{time}\eqn{\times (3M + 2) \times N_{ens}} \code{array} (where \eqn{M} is the number of simulators and \eqn{N_{ens}} is the number of samples from the ensemble model), giving the MLE of the latent variables for each available sample from the ensemble model.
\item \code{sample} is a \code{time}\eqn{\times (3M + 2) \times N_{ens}} \code{array}, giving a sample of the latent variables for each available sample of the ensemble model.
}
\item If \code{fit} is a point estimate of the ensemble model, then:
\itemize{
\item \code{mle} is a \code{time}\eqn{\times (3M + 2) \times} 1 \code{array} giving the MLE of the latent variables for the point estimate
of the ensemble model.
\item \code{sample} is a \code{time}\eqn{\times (3M + 2) \times} \code{num_samples} \code{array}, giving \code{num_samples} samples of the latent variables for the single point estimate of the ensemble model.
}
}

\code{get_transformed_data} gives a \code{list} of transformed input data in discrepancy space.

\code{get_parameters} gives a \code{list} of ensemble parameters from the requested sample.

\code{get_mle} gives the MLE of the latent variables for the the requested sample of ensemble parameter values. (matrix?)

\code{gen_sample} gives a sample from the latent variables for the the requested sample of ensemble parameter values. (matrix/array?)
}
\description{
Methods to generates samples of the latent variables from a fitted ensemble model.
}
\details{
The samples are created using the methods described in ....
}
\examples{
N_species <- 4
priors <- define_priors(ind_st_var_params = list(25, 0.25),
                       ind_st_cor_form = "lkj", #Using an LKJ distribution for individual short-term discrepancie
                       ind_st_cor_params = 30, #The parameter is 30
                       ind_lt_var_params = list(rep(25,N_species),rep(0.25,N_species)),
                       ind_lt_cor_form = "beta",
                       ind_lt_cor_params = list(matrix(40,N_species, N_species), matrix(40, N_species, N_species)
                                                sha_st_var_exp = 3,
                                                sha_st_cor_form = "lkj",
                                                sha_st_cor_params = 30,
                                                sha_lt_sd = rep(4,N_species)))
fit <- fit_ensemble_model(observations = list(SSB_obs, Sigma_obs),
                         simulators = list(list(SSB_ewe, Sigma_ewe, "EwE"),
                                           list(SSB_fs,  Sigma_fs, "FishSUMS"),
                                           list(SSB_lm,  Sigma_lm, "LeMans"),
                                           list(SSB_miz, Sigma_miz, "Mizer")),
                         priors = priors)
sample <- generate_sample(fit, num_samples = 2000)

# A quicker way to get the MLE for the first sample from the ensemble
transf_data <- get_transformed_data(fit)
ex.fit <- rstan::extract(fit@ex.fit)
mle_sample <- get_mle(1, ex.fit = ex.fit, transformed_data = transformed_data,
                     time = fit@ensemble_data@stan_input$time, simplify = F)

}
\references{
the one I forgot.
}
