% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_stan_outputs.R
\name{generate_sample}
\alias{generate_sample}
\alias{get_transformed_data}
\alias{get_parameters}
\alias{get_mle}
\alias{gen_sample}
\title{Generate samples from a fitted ensemble model.}
\usage{
generate_sample(fit, num_samples = 1)

get_transformed_data(fit)

get_parameters(ex.fit, x = 1)

get_mle(x = 1, ex.fit, transformed_data, time)

gen_sample(x = 1, ex.fit, transformed_data, time)
}
\arguments{
\item{fit}{An \code{EnsembleFit} fitted ensemble object, an output from the \code{fit_ensemble_model} function.}

\item{num_samples}{The number of samples to generate from the Kalman filter if the \code{EnsembleFit} object is not a full sampling
of the posterior of the ensemble model. The default is 1. If the \code{EnsembleFit} object is a full sampling of the posterior, then the
number of samples will be the same as the number of samples in the ensemble MCMC.}

\item{ex.fit}{The extracted samples / point estimate from the \code{EnsembleFit} object. For samples, this should be the output
of \code{rstan::extract()} on the \code{stanfit} object and for point estimate outputs this should be the \code{par} slot.}

\item{x}{The sample of parameters from the ensemble model to use (if the \code{EnsembleFit} object is a full sampling, otherwise
uses the MLE). The default is 1.}

\item{time}{A non-negative integer specifying the time for which the ensemble model was run.}
}
\value{
\code{generate_sample} gives a \code{list} of length 2, with the first element being the MLE of the Kalman filter and
the second element being samples.
\itemize{
\item If \code{fit} is a full MCMC sampling of the ensemble model, then:
\itemize{
\item \code{mle} is a \code{time}\eqn{\times (3M + 2) \times N_{ens}} \code{array} (where \eqn{M} is the number of simulators
and \eqn{N_{ens}} is the number of samples from the ensemble model), giving the MLE of the Kalman filter for
each available sample of the ensemble model.
\item \code{sample} is a \code{time}\eqn{\times (3M + 2) \times N_{ens}} \code{array}, giving a sample of the Kalman filter for
each available sample of the ensemble model.
}
\item If \code{fit} is a point estimate of the ensemble model, then:
\itemize{
\item \code{mle} is a \code{time}\eqn{\times (3M + 2) \times} 1 \code{array} giving the MLE of the Kalman filter for the point estimate
of the ensemble model.
\item \code{sample} is a \code{time}\eqn{\times (3M + 2) \times} \code{num_samples} \code{array}, giving \code{num_samples} samples of the Kalman filter for
the single point estimate of the ensemble model.
}
}

\code{get_transformed_data} gives a \code{list} of transformed input data in discrepancy space.

\code{get_parameters} gives a \code{list} of ensemble parameters from the requested sample.

\code{get_mle} gives the MLE of the Kalman filter for the the requested sample of ensemble parameter values.

\code{gen_sample} gives a sample from the Kalman filter for the the requested sample of ensemble parameter values.
}
\description{
Methods to generates samples of the latent variables in the ensemble model by sampling from
the Kalman filter. It is strongly recommended to use the \code{generate_sample} wrapper function,
but subroutiones are provided to allow finer control if desired.
}
\details{

}
\examples{
# Basic usage of the generate sample function
fit_sample <- fit_ensemble_model(observations = list(SSB_obs, Sigma_obs),
                         simulators = list(list(SSB_ewe, Sigma_ewe, "EwE"),
                                           list(SSB_fs,  Sigma_fs, "FishSUMS"),
                                           list(SSB_lm,  Sigma_lm, "LeMans"),
                                           list(SSB_miz, Sigma_miz, "Mizer")),
                         priors = priors)
sample <- generate_sample(fit_sample, num_samples = 2000)

# A quicker way to get the MLE for the first sample from the ensemble
transf_data <- get_transformed_data(fit_sample)
ex.fit <- rstan::extract(fit$ex.fit)
mle_sample <- get_mle(1, ex.fit = ex.fit, transformed_data = transformed_data,
                     time = fit$stan_input$time, simplify = F)

}
